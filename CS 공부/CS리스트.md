#### 절차지향프로그래밍

이름 그대로 절차, 순차적인 처리가 중요시 된다. 데이터를 중심으로 함수를 구현한다. 대표적인 언어로는 C언어가 있다.

장점 - 객체지향 언어를 사용하는것에 비해 처리 속도가 빠르다.

단점 - 유지보수가 없다. 디버깅이 어렵다. 실행 순서가 정해져 있어, 순서가 바뀌면 결과를 보장하기 어렵다.

#### 객체지향프로그래밍

데이터와 절차를 하나의 덩어리로 묶어서 생각한다. 기능을 중심으로 메소드를 구현한다. 대표적인 언어로는 JAVA, Python, C++, C# 등이 있다.

장점 - 코드의 재활용성이 높다, 디버깅이 쉽다, 절차지향보다 간편하다

단점 - 처리속도가 절차지향보다 느리다, 설계에 많은 시간요소가 들어간다

특성 

- 캡슐화 - 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없게 하는 것
- 상속 - 상위 개체의 속성이 하위 개체에 물려져서, 하위 개체가 상위 개체의 속성을 모두 가지는 관계
- 다형성 - 같은 이름의 메소드가 클래스 혹은 객체에 따라 다르게 구현
  - 실세계에서 예로, 동물은 소리를 낼 수 있지만, 강아지는 '멍멍', 고양이는 '야옹', 오리는 '꽥꽥' 등 우는 것처럼 낼 수 있는 소리는 다양하다.

#### HTTP(HyperText Transfer Protocol)

HTML 문서를 교환하기 위해 만들어진 통신 규약

즉 웹상에서 네트워크로 서버끼리 통신을 할때 어떠한 형식으로 서로 통신을 하자고 규정해 놓은 "통신 형식" 혹은 "통신 구조" 라고 보면 된다.

HTTP 기본적으로 **request**(요청)/**response**(응답) 구조로 되어있다.
클라이언트가 HTTP request를 서버에 보내면 서버는 HTTP response를 보내는 구조
클라이언트와 서버의 모든 통신이 요청과 응답으로 이루어 진다.

#### HTTPS

HTTPS는 기본 골격이나 사용 목적 등은 HTTP와 거의 동일하지만, 데이터를 주고 받는 과정에 ‘보안’ 요소가 추가되었다는 것이 가장 큰 차이점. HTTPS를 사용하면 **서버와 클라이언트 사이의 모든 통신 내용이 암호화**된다.

MSA란

MSA의 장점

프로토콜의 개념, 요소, 특징, 계층 구성

#### 동기

요청과 결과가 한 자리에서 동시에 일어난다. 

한 개의 데이터 요청에 대한 서버의 응답이 이루어질 때까지 계속 대기해야만 한다. 

=> 여러 가지 요청을 동시에 처리할 수 없다.

장점 : 설계가 매우 간단하고 직관적이다.

단점 : 결과가 주어질 때까지 아무것도 못하고 대기해야 합니다.

#### 비동기

요청한 결과는 동시에 일어나지 않을거라는 약속

하나의 요청에 따른 응답을 즉시 처리하지 않아도, 그 대기 시간동안 또 다른 요청에 대해 처리 가능한 방식이다.

장점 : 요청에 따른 결과가 반환되는 시간 동안 다른 작업을 수행할 수 있습니다.

단점 : 동기식보다 설계가 복잡합니다.

#### 시간 복잡도

알고리즘이 문제를 해결하기 위한 시간(연산)의 횟수

- 수행시간 - 시간 복잡도
- 메모리 사용량 - 공간 복잡도

quiz) 시간 복잡도가 낮으면 무조건 실행이 빨리 종료될까??



### HTML

웹페이지를 만들기 위한 언어로 웹브라우저 위에서 동작하는 언어

### 객체지향 프로그래밍

모든 데이터를 객체 취급하며, 처리요청을 받은 객체는 객체 그 안의 기능을 사용해 요청을 처리합니다.

특징으로는 캡슐화, 상속, 다형성, 추상화 등이 있고, 모듈 재사용으로 확장 및 유지보수가 용이합니다.

### 추상 클래스, 인터페이스

- 추상 클래스는 클래스 내 추상 메소드가 하나 이상 포함되거나 abstract로 정의된 경우를 말하고,

- 인터페이스는 모든 메소드가 추상 메소드로만 이루어져 있는 것을 말합니다.

### 클래스, 객체

클래스는 객체를 만들어내기 위한 설계도 혹은 틀이라고 할 수 있고, 객체를 생성하는데 사용

객체는 클래스를 기반으로 생성되며, 자신의 고유 이름과 상태(필드), 행동(메소드)을 갖는다

### 생성자

클래스와 같은 이름의 메소드로, 객체가 생성될 때 호출되는 메소드이다.

### GET

클라이언트에서 서버로 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 메소드

ex) 게시판 조회등

GET을 통한 요청은 URL주소 끝에 파라미터로 포함되어 전송되며, 쿼리 스트링이라고 부른다

ex) [www.example.com/show?name1=value1&name2=value2](www.example.com/show?name1=value1&name2=value2)

### POST

POST는 클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용 되는 메서드다.

ex) 게시글 작성, 수정등

POST는 전송할 데이터를 HTTP 메시지 body 부분에 담아서 서버로 보낸다.

GET 방식이 POST 방식보다 속도가 빠른이유?

GET방식의 요청은 캐싱하기 때문이다.

- 캐싱 - 한번 접근 후, 또 요청할 시 빠르게 접근하기 위해 데이터를 저장

> GET에서 URL 의 파라미터로 보냈던 name1=value1&name2=value2 가 body에 담겨 보내진다 생각하면 된다.

### RDBMS vs NoSQL

**RDBMS**는 모든 데이터를 2차원 테이블 형태로 표현합니다.

데이터 구조가 명확하고, 변경될 여지가 없으며 스키마가 중요한 경우 사용에 용이

- 장점 : 스키마에 맞춰 데이터를 관리하기 때문에 데이터의 정합성을 보장할 수 있다.

- 단점 : 시스템이 커질 수록 쿼리가 복잡해지고 성능이 저하되며 Scale-out이 어렵다(Scale-up만 가능)

**NoSQL**(Not Only SQL)은 RDBMS와 반대로 데이터간의 관계를 정의하지 않고, 스키마가 없어 좀 더 자유롭게 데이터를 관리할 수 있으며, 컬렉션이라는 형태로 데이터를 관리합니다.

정확한 데이터 구조를 알 수 없고 데이터가 변경/확장 될 수 있는 경우 사용에 용이

- **장점** : 스키마 없이 Key-Value 형태로 데이터를 관리해 자유롭게 데이터를 관리할 수 있다.

- 데이터 분산이 용이하여 성능 향상을 위한 scale-up 뿐만아닌 scale-out 또한 가능하다.

- **단점** : 데이터 중복이 발생할 수 있고, 중복된 데이터가 변경될 경우 수정을 모든 컬렉션에서 수행해야 한다.

- 스키마가 존재하지 않기에 명확한 데이터 구조를 보장하지 않아 데이터 구조 결정이 어려울 수 있다.

### inner join vs outer join

**inner join** 은 서로 연관된 내용만 검색하는 조인 방법입니다.

**outer join** 은 한 쪽에는 데이터가 있고 한 쪽에는 데이터가 없는 경우, 데이터가 있는 쪽의 내용을 전부 출력하는 방법입니다.

### PK

Primary Key 의 약어로 데이터베이스의 기본키를 의미한다.

기본키는 후보키 중에서 특별히 선정된 키로 중복된 값을 가질 수 없다.

유일성과 최소성을 가지며 튜플을 식별하기 위해 반드시 필요한 키이다.

NULL 값이 있어서도 안된다.

### FK

Foreign Key 의 약어로 외래키를 의미한다.

외래키는 다른 릴레이션의 기본키를 참조하는 속성 또는 속성들의 집합을 의미한다.

릴레이션 간의 관계를 표현할 때 사용한다.

참조 릴레이션의 기본키와 동일한 키 속성을 가진다.

### Spring Boot vs Spring Framework

가장 큰 차이점은 Auto Configuration

Spring은 프로젝트 초기에 다양한 환경설정을 해야 하지만, Spring Boot는 설정의 많은 부분을 자동화하여 사용자가 편하게 스프링을 활용할 수 있도록 돕는다.

### IoC

모든 객체에 대한 제어권을 개발자가 아닌 IoC 컨테이너에게 넘긴 것.

### DI

필요한 객체를 직접 생성하는 것이 아닌 외부로부터 객체를 받아서 사용하는 것

객체간의 결합도를 줄이고 코드의 재사용성을 높일 수 있다

### MVC패턴

**MVC** (모델-뷰-컨트롤러) 는 사용자 인터페이스, 데이터 및 논리 제어를 구현하는데 널리 사용되는 소프트웨어 디자인 패턴입니다. 각각의 구성 요소가 다른 요소들에게 영향을 미치지 않아야 한다.

디자인 패턴이란 프로그램이나 어떤 특정한 것을 개발하는 중에 발생했던 문제점들을 정리해서 상황에 따라 간편하게 적용해서 쓸 수 있는 것을 정리하여 특정한 "규약"을 통해 쉽게 쓸 수 있는 형태로 만든 것을 말합니다.

1. 모델: 데이터와 비즈니스 로직을 관리합니다.

2. 뷰: 레이아웃과 화면을 처리합니다.

3. 컨트롤러: 명령을 모델과 뷰 부분으로 라우팅합니다.

웹에서의 MVC

모델 - 애플래케이션의 정보, 데이터. 처음의 정의 하는 상수, 초기화 값, 변수 등

뷰 - 데이터를 기반으로 사용자들이 볼 수 있는 화면

컨트롤러 - 사용자가 데이터를 클릭하고, 수정하는 것에 대한 **이벤트**들을 처리하는 부분

데이터와 사용자 인터페이스 요소들을 잇는 다리역할

- 사용이유

> 서로 분리되어 각자의 역할에 집중할 수 있게끔하여 개발을 하고 그렇게 애플리케이션을 만든다면, 유지보수성, 애플리케이션의 확장성, 그리고 유연성이 증가하고, 중복코딩이라는 문제점 또한 사라지게 되는 것입니다.

### MTV패턴

장고의 디자인 패턴

- Model - DB에 저장되는 데이터

장고는 ORM(**Object Relational Mapping**)기능을 지원하기 때문에 파이썬 코드로 DB를 조작

- Template - MVC패턴의 뷰에 대응 **html 파일 내에서 context로 받은 데이터를 활용할 수 있습니다.**

- View - MVC패턴의 컨트롤러에 대응 **요청에 따라 적절한 로직을 수행하여 결과를 템플릿으로 렌더링하며 응답**

여기에 장고는 **URLConf(URL 설계)라는 단계가 하나 더 있습니다.**

from django.urls import path  
from . import views  
​  
app_name = 'project'  
​  
urlpatterns = [  
    path('', views.HomeView.as_view(), name='home'),  
    path('login/', views.LoginView.as_view(), name='login'),  
]

이와 같이 path함수를 이용해 URL을 뷰와 손쉽게 매핑시킬 수 있습니다.

### 트랜잭션

트랜잭션은 은행 ATM이나 데이터베이스 등의 시스템에서 사용되는 더 이상 쪼갤 수 없는 업무 처리의 최소 단위이다.

트랜잭션 처리가 정상적으로 완료된 경우 커밋을 하고 오류가 발생할 경우 원래 상태대로 롤백을 한다.

트랜잭션은 데이터베이스 서버에 여러 명의 클라이언트가 동시에 액세스 하거나 응용프로그램이 갱신을 처리하는 과정에서 중단될 수 있는 경우 등 데이터 부정합을 방지하고자 할 때 사용한다.

### 자바에서 상속

> 상속을 사용하는 이유는 빠르고 , 유지보수가 쉽고 , 중복이 적고, 통일성이 있는 프로그램을 만들기 위해서이다.

자식 클래스가 부모 클래스로부터 상속을 받게 되면 부모 클래스의 필드와 메소드를 물려받게 된다.

단, 접근 제어자 private을 갖는 필드가 메소드는 상속이 불가하고, 패키지가 다를 경우 접근 제어자가 default인 경우여도 상속이 불가하다.

### 핀테크란

금융에 IT기술을 접목하여 복잡하고 어려웠던 금융을 효율적으로 편리하게 서비스하는 것.

10년전부터 사용하던 온라인 뱅킹도 일종의 핀테크

공인인증서나 보안카드 같은 불편함을 해결

### 오버라이딩 오버로딩

- 오버라이딩(Overriding)은 상위 클래스에 있는 메소드를 하위 클래스에서 재정의 하는 것을 말하고,

- 오버로딩(Overloading)은 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메소드를 여러 개 정의하는 것을 말합니다.



### AJAX

- javascript 라이브러리 중 하나
- javascript 사용한 비동기 통신, 클라이언트와 서버간에 xml 데이터를 주고 받는 기술
- 즉, javascript를 통해서 서버에 데이터를 요청
- 장점
  - 웹페이지의 속도향상
  - 서버에서 data만 전송하면 되므로 전체적인 코딩의 양이 줄어든다
- 단점
  - script로 작성되므로 디버깅이 용이하지 않다
  - 히스토리 관리가 되지 않는다



### 싱글톤 패턴

-  객체의 인스턴스가 오직 1개만 생성되는 패턴
- 장점
  - 메모리 측면의 이점
    - 한개의 인스턴스만을 고정 메모리 영역에 생성하고 추후 해당 객체를 접근할 때 메모리 낭비를 방지할 수 있다.
  - 속도 측면의 이점
    - 생성된 인스턴스를 사용할 때는 이미 생성된 인스턴스를 활용하여 속도 측면에 이점이 있다.
  - 데이터 공유가 쉽다
    - 전역으로 사용하는 인스턴스이기 때문에 다른 여러 클래스에서 데이터를 공유하며 사용할 수 있다. 하지만 동시성 문제가 발생할 수 있어 이 점은 유의하여 설계하여야 한다.

- 단점
  - 인스턴스가 너무 많을 일을 하거나 많은 데이터를 공유시킬 경우에 다른 클래스의 인스턴스들간의 결합도가 높아져 개방-폐쇄 원칙을 위배하게 된다.
    - 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계가 되어야 한다는 원칙
  - 이는 객체 지향 설계 원칙에 어긋나기 때문에 수정이 어려워지고 유지보수의 비용이 높아질 수 있다.





중앙처리장치(CPU)개념

도메인

ipv4 ipv6

GPU란?

세션 기반 인증과 토큰 기반 인증의 차이

쿠기와 세션의 차이

컴파일러란?

우리가 구글 페이지를 어떻게 들어갈 수 있는가

API

RESTAPI

Git

Github

mysql vs nosql
