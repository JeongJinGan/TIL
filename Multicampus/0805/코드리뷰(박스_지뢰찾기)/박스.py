# 조건
# 1. 현재 박스 아래에 박스가 없어야 한다.
# 박스 = 1
# 빈공간 = 0
# y, x = 2, 0
# if 박스_리스트[y+1][x] != 박스: # 2,0에서 y+1이면 3,0 에 박스가 없어야 한다
# 
# 2. 박스는 바닥을 벗어나면 안된다.
# -> 리스트의 범위를 벗어나면 안된다.
# 리스트의 크기
# m x n
# m, n = 5, 4
# if y + 1 != m:
#
# 박스 이동
# 현재 위치는 0 저장 아래 위치는 1 저장
# 박스 = 1
# 빈공간 = 0
# y, x = 2, 0
# while 조건: ---> 조건 = 위에 조건1 and 조건2 
# (while 박스_리스트[y+1][x] != 박스 and y + 1 != 행길이:)
#   박스_리스트[y+1][x] = 박스
#   박스_리스트[y][x] = 빈공간
#   y += 1


박스 = 1
빈공간 = 0
행_개수, 열_개수 = 5, 4

박스_리스트 = [
    [1, 0, 0, 0],
    [0, 0, 1, 0],
    [1, 0, 0, 1],
    [0, 1, 0, 0],
    [1, 0, 1, 0]
]

이동거리 = 0

# 이중 반복문
# 열부터 순회
for x in range(열_개수):
# 행순회 - 단, 아래에서 위로 탐색
    # 4부터 0까지 -1
    for y in range(행_개수-1, -1, -1):
    # 위에 for문을 못쓰겠다면
    # for y in reversed(range(행_개수)):
        # 만약에 현재 탐색하고(보고)있는 좌표에 박스가 있으면
        if 박스_리스트[y][x] == 박스:
            # while y+1 != 행_개수 and 박스_리스트[y+1][x] != 박스:
            while True:

                # 범위를 체크 1순위
                if y+1 == 행_개수:
                    break
                # 값을 체크
                if 박스_리스트[y+1][x] == 박스:
                    break

                박스_리스트[y][x] = 빈공간
                박스_리스트[y+1][x] = 박스
                y += 1
                이동거리 += 1
print(이동거리)
            # 조건 1. 박스 아래에 박스가 없어야한다.
            # if 박스_리스트[y+1][x] != 박스:

            # 조건 2. 박스가 바닥을 벗어나면 안된다
            # -> 리스트의 범위를 벗어나면 안된다
            # if y+1 != 행_개수:





